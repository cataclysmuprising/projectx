diff --git a/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepository.java b/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepository.java
index 537eb108a783394e0e8cb63a918ced8ce4b91c7a..67cc83240dfb13731153a23dfc0ecc7d6c639894 100644
--- a/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepository.java
+++ b/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepository.java
@@ -1,59 +1,58 @@
 package com.tamantaw.projectx.persistence.repository.base;

 import com.querydsl.core.types.dsl.EntityPathBase;
 import com.tamantaw.projectx.persistence.criteria.base.AbstractCriteria;
 import com.tamantaw.projectx.persistence.entity.base.AbstractEntity;
 import org.springframework.data.domain.Page;

 import java.io.Serializable;
 import java.util.List;
 import java.util.Optional;

 public interface AbstractRepository<
-		ID extends Serializable,
+		ID extends Serializable & Comparable<ID>,
 		ENTITY extends AbstractEntity,
 		QCLAZZ extends EntityPathBase<ENTITY>,
 		CRITERIA extends AbstractCriteria<QCLAZZ>
 		> {

 	// ------------------------------
 	// ENTITY READS (internal/domain)
 	// ------------------------------
 	Optional<ENTITY> findById(ID id);

 	Optional<ENTITY> findOne(CRITERIA criteria, String... hints);

 	List<ENTITY> findAll(CRITERIA criteria, String... hints);

 	Page<ENTITY> findByPaging(CRITERIA criteria, String... hints);

 	// ------------------------------
 	// ID-BASED READS (safe)
 	// ------------------------------
 	List<ID> findIds(CRITERIA criteria);

 	long count(CRITERIA criteria);

 	boolean exists(CRITERIA criteria);

 	// ------------------------------
 	// WRITE
 	// ------------------------------
 	ENTITY saveRecord(ENTITY entity);

 	List<ENTITY> saveAllRecords(Iterable<ENTITY> entities);

 	long updateById(UpdateSpec<ENTITY> spec, ID id, long updatedBy);

 	<E extends ENTITY> long updateByCriteria(UpdateSpec<E> spec, CRITERIA criteria, Long updatedBy);

 	/**
 	 * Deletes a single entity by ID.
 	 *
 	 * @return true if deleted, false if not found
 	 */
 	boolean deleteWithId(ID id);

 	long deleteByCriteria(CRITERIA criteria);
 }
-
diff --git a/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepositoryImpl.java b/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepositoryImpl.java
index 211977c567004172d05e3bab6e950ca66a155a95..c3134bd27fdff002a25867448445aa5a724204d5 100644
--- a/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepositoryImpl.java
+++ b/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepositoryImpl.java
@@ -1,87 +1,90 @@
 package com.tamantaw.projectx.persistence.repository.base;

+import com.querydsl.core.JoinExpression;
 import com.querydsl.core.types.*;
 import com.querydsl.core.types.dsl.*;
 import com.querydsl.jpa.JPQLQuery;
 import com.querydsl.jpa.impl.AbstractJPAQuery;
 import com.querydsl.jpa.impl.JPAQueryFactory;
 import com.querydsl.jpa.impl.JPAUpdateClause;
 import com.tamantaw.projectx.persistence.criteria.base.AbstractCriteria;
 import com.tamantaw.projectx.persistence.entity.base.AbstractEntity;
 import com.tamantaw.projectx.persistence.entity.base.QAbstractEntity;
 import jakarta.annotation.Nonnull;
+import jakarta.persistence.EntityGraph;
 import jakarta.persistence.EntityManager;
+import jakarta.persistence.Subgraph;
 import jakarta.persistence.metamodel.*;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.PageImpl;
 import org.springframework.data.domain.Pageable;
 import org.springframework.data.jpa.repository.support.*;
 import org.springframework.data.querydsl.EntityPathResolver;
 import org.springframework.data.querydsl.SimpleEntityPathResolver;
 import org.springframework.util.Assert;

 import java.io.Serializable;
 import java.lang.reflect.Field;
 import java.time.LocalDateTime;
 import java.util.*;

 /**
  * Base JPA repository implementation with:
  * <p>
  * - QueryDSL-based dynamic criteria
  * - N+1-safe fetching
  * - Pagination-safe ordering
  * - Deterministic results across databases
  * - Explicit API contracts
  *
  * <p>
  * This class intentionally avoids “magic behavior”.
  * Every performance-critical decision is explicit and documented.
  * </p>
  *
  * <p><b>STRICT GUARANTEE</b></p>
  * <ul>
  *   <li>❌ Hibernate in-memory paging</li>
  *   <li>❌ Duplicate entities</li>
  *   <li>❌ Missing records</li>
  *   <li>❌ Broken pagination with joins</li>
  *   <li>❌ Incorrect total counts</li>
  *   <li>❌ Non-deterministic ordering</li>
  * </ul>
  *
  * <p>
  * If the caller requests an unsafe operation (e.g. to-many ORDER BY),
  * this repository fails fast with a clear exception. There is no “best effort”
  * fallback that could silently corrupt paging results.
  * </p>
  */
 public abstract class AbstractRepositoryImpl<
-		ID extends Serializable,
+		ID extends Serializable & Comparable<ID>,
 		ENTITY extends AbstractEntity,
 		QCLAZZ extends EntityPathBase<ENTITY>,
 		CRITERIA extends AbstractCriteria<QCLAZZ>>
 		extends SimpleJpaRepository<ENTITY, ID>
 		implements AbstractRepository<ID, ENTITY, QCLAZZ, CRITERIA> {

 	// ----------------------------------------------------------------------
 	// STATIC CONFIGURATION
 	// ----------------------------------------------------------------------

 	/**
 	 * Indicates whether the underlying database is PostgreSQL.
 	 *
 	 * <p><b>Why this flag exists</b></p>
 	 * <ul>
 	 *   <li>
 	 *     PostgreSQL guarantees stable ORDER BY semantics when reapplying
 	 *     sorting after an ID-based paging query.
 	 *   </li>
 	 *   <li>
 	 *     PostgreSQL optimizes OFFSET / LIMIT efficiently even on complex queries.
 	 *   </li>
 	 *   <li>
 	 *     Other databases do NOT guarantee order preservation for
 	 *     <code>IN (...)</code> queries and therefore require explicit ordering.
@@ -144,86 +147,251 @@ public abstract class AbstractRepositoryImpl<
 		QCLAZZ resolved = (QCLAZZ) PATH_RESOLVER.createPath(domainClass);
 		path = resolved;

 		PathBuilder<ENTITY> builder =
 				new PathBuilder<>(path.getType(), path.getMetadata());

 		querydsl = new Querydsl(entityManager, builder);
 		queryFactory = new JPAQueryFactory(entityManager);

 		audit = resolveAuditPath(path);

 		IdentifiableType<ENTITY> identifiable =
 				(IdentifiableType<ENTITY>) entityManager
 						.getMetamodel()
 						.managedType(domainClass);

 		SingularAttribute<? super ENTITY, ID> idAttr =
 				identifiable.getId(idClass);

 		idExpr = Expressions.simplePath(
 				idClass,
 				path,
 				idAttr.getName()
 		);

+		if (!Comparable.class.isAssignableFrom(idClass)) {
+			throw new IllegalStateException(
+					"ID type must be Comparable for deterministic paging. idClass=" + idClass.getName()
+			);
+		}
+
 		@SuppressWarnings("unchecked")
 		Expression<? extends Comparable<?>> comparableIdExpr =
 				(Expression<? extends Comparable<?>>) idExpr;

 		idAscOrder = new OrderSpecifier<>(Order.ASC, comparableIdExpr);
 	}

 	// ----------------------------------------------------------------------
 	// READ OPERATIONS
 	// ----------------------------------------------------------------------

-	protected static QueryHints getRelatedDataHints(String... hints) {
-		if (ArrayUtils.isNotEmpty(hints)) {
-			MutableQueryHints qh = new MutableQueryHints();
-			qh.add("jakarta.persistence.fetchgraph", String.join(",", hints));
-			return qh;
+	protected QueryHints getRelatedDataHints(String... hints) {
+
+		if (ArrayUtils.isEmpty(hints)) {
+			return null;
+		}
+
+		EntityGraph<?> graph = entityManager.createEntityGraph(path.getType());
+		ManagedType<?> rootType = entityManager.getMetamodel().managedType(path.getType());
+
+		for (String hint : hints) {
+			if (hint == null || hint.isBlank()) {
+				continue;
+			}
+			String graphSpec = normalizeGraphSpec(hint, rootType.getJavaType().getSimpleName());
+			applyGraphSpec(new EntityGraphContainer(graph), rootType, graphSpec);
 		}
-		return null;
+
+		MutableQueryHints qh = new MutableQueryHints();
+		qh.add("jakarta.persistence.fetchgraph", graph);
+		return qh;
 	}

 	private static <T> List<List<T>> chunk(List<T> src, int size) {

 		if (src == null || src.isEmpty()) {
 			return List.of();
 		}

 		List<List<T>> out =
 				new ArrayList<>((src.size() + size - 1) / size);

 		for (int i = 0; i < src.size(); i += size) {
 			out.add(src.subList(i, Math.min(src.size(), i + size)));
 		}

 		return out;
 	}

+	/**
+	 * Strictly deduplicates root entities by ID while preserving order.
+	 */
+	protected Map<ID, ENTITY> deduplicateById(List<ENTITY> rows) {
+
+		if (rows == null || rows.isEmpty()) {
+			return Map.of();
+		}
+
+		Map<ID, ENTITY> unique = new LinkedHashMap<>(rows.size());
+
+		for (ENTITY e : rows) {
+			@SuppressWarnings("unchecked")
+			ID id = (ID) e.getId();
+			unique.putIfAbsent(id, e);
+		}
+
+		return unique;
+	}
+
+	protected String normalizeGraphSpec(String graph, String rootName) {
+
+		if (graph == null) {
+			return "";
+		}
+
+		graph = graph.trim();
+		if (graph.isEmpty()) {
+			return "";
+		}
+
+		// Strip optional root prefix "Role(...)" to reuse the inner specification.
+		int start = graph.indexOf('(');
+		int end = graph.lastIndexOf(')');
+		if (start >= 0 && end > start) {
+			return graph.substring(start + 1, end);
+		}
+
+		// If the graph is just the root name, treat it as empty.
+		if (graph.equals(rootName)) {
+			return "";
+		}
+
+		return graph;
+	}
+
+	protected void applyGraphSpec(GraphContainer graph, ManagedType<?> rootType, String graphSpec) {
+
+		if (graphSpec == null || graphSpec.isBlank()) {
+			return;
+		}
+
+		int idx = 0;
+		while (idx < graphSpec.length()) {
+
+			int nextParen = graphSpec.indexOf('(', idx);
+			int nextComma = graphSpec.indexOf(',', idx);
+
+			int end = minPositive(nextParen, nextComma, graphSpec.length());
+			if (end < 0) {
+				end = graphSpec.length();
+			}
+
+			String attrName = graphSpec.substring(idx, end).trim();
+
+			if (!attrName.isEmpty()) {
+				Attribute<?, ?> attr = rootType.getAttribute(attrName);
+
+				if (nextParen >= 0 && nextParen == end) {
+					int close = findMatchingParen(graphSpec, nextParen);
+					String nested = graphSpec.substring(nextParen + 1, close);
+
+					ManagedType<?> nestedType = resolveManagedType(attr);
+					Subgraph<?> subgraph = graph.addSubgraph(attr, nestedType);
+					applyGraphSpec(new SubgraphContainer(subgraph), nestedType, nested);
+					idx = close + 1;
+					continue;
+				}
+				graph.addAttribute(attrName);
+			}
+
+			idx = end + 1;
+		}
+	}
+
+	protected ManagedType<?> resolveManagedType(Attribute<?, ?> attr) {
+
+		if (attr instanceof SingularAttribute<?, ?> sa) {
+			if (sa.getType() instanceof ManagedType<?> mt) {
+				return mt;
+			}
+		}
+
+		if (attr instanceof PluralAttribute<?, ?, ?> pa) {
+			if (pa.getElementType() instanceof ManagedType<?> mt) {
+				return mt;
+			}
+		}
+
+		throw new IllegalStateException(
+				"Attribute '" + attr.getName() + "' is not an entity path and cannot have nested graph hints"
+		);
+	}
+
+	protected interface GraphContainer {
+		void addAttribute(String attribute);
+
+		Subgraph<?> addSubgraph(Attribute<?, ?> attr, ManagedType<?> nestedType);
+	}
+
+	protected static final class EntityGraphContainer implements GraphContainer {
+		private final EntityGraph<?> delegate;
+
+		EntityGraphContainer(EntityGraph<?> delegate) {
+			this.delegate = delegate;
+		}
+
+		@Override
+		public void addAttribute(String attribute) {
+			delegate.addAttributeNodes(attribute);
+		}
+
+		@Override
+		public Subgraph<?> addSubgraph(Attribute<?, ?> attr, ManagedType<?> nestedType) {
+			return delegate.addSubgraph(attr.getName(), nestedType.getJavaType());
+		}
+	}
+
+	protected static final class SubgraphContainer implements GraphContainer {
+		private final Subgraph<?> delegate;
+
+		SubgraphContainer(Subgraph<?> delegate) {
+			this.delegate = delegate;
+		}
+
+		@Override
+		public void addAttribute(String attribute) {
+			delegate.addAttributeNodes(attribute);
+		}
+
+		@Override
+		public Subgraph<?> addSubgraph(Attribute<?, ?> attr, ManagedType<?> nestedType) {
+			return delegate.addSubgraph(attr.getName(), nestedType.getJavaType());
+		}
+	}
+
 	/**
 	 * Simple primary-key lookup.
 	 */
 	@Override
 	@Nonnull
 	public Optional<ENTITY> findById(@Nonnull ID id) {
 		Assert.notNull(id, "Id must not be null");
 		return super.findById(id);
 	}

 	/**
 	 * Returns exactly one entity or empty.
 	 *
 	 * <p>
 	 * The criteria MUST be logically unique.
 	 * If more than one row matches, an exception is thrown.
 	 * </p>
 	 */
 	@Override
 	public Optional<ENTITY> findOne(CRITERIA criteria, String... hints) {

 		Assert.notNull(criteria, "Criteria must not be null");

 		Predicate filter = criteria.getFilter(path);

@@ -242,50 +410,51 @@ public abstract class AbstractRepositoryImpl<
 			JPQLQuery<ENTITY> query =
 					createQuery(filter, hints).select(path);

 			applySortOrDefaultById(query, criteria);

 			List<ENTITY> rows = query.limit(2).fetch();

 			if (rows.isEmpty()) {
 				return Optional.empty();
 			}
 			if (rows.size() > 1) {
 				throw new IllegalStateException(
 						"findOne() returned more than one result"
 				);
 			}
 			return Optional.of(rows.getFirst());
 		}

 		// ------------------------------------------------------------
 		// SAFE PATH — collection fetch (ID first)
 		// ------------------------------------------------------------
 		JPQLQuery<ID> idQuery =
 				createQuery(filter).select(idExpr);

 		applySortOrDefaultById(idQuery, criteria);
+		assertNoAdditionalJoins((AbstractJPAQuery<?, ?>) idQuery, "findOne.idQuery");

 		List<ID> ids = idQuery.limit(2).fetch();

 		if (ids.isEmpty()) {
 			return Optional.empty();
 		}
 		if (ids.size() > 1) {
 			throw new IllegalStateException(
 					"findOne() returned more than one result"
 			);
 		}

 		JPQLQuery<ENTITY> entityQuery =
 				createQuery(idExpr.eq(ids.getFirst()), hints)
 						.select(path);

 		return Optional.ofNullable(entityQuery.fetchOne());
 	}

 	// ----------------------------------------------------------------------
 	// ID / COUNT / EXISTS
 	// ----------------------------------------------------------------------

 	/**
 	 * Returns all matching entities without pagination.
@@ -311,75 +480,72 @@ public abstract class AbstractRepositoryImpl<
 		boolean requiresIdFirst =
 				fetchGraphContainsCollection(hints);

 		// ------------------------------------------------------------
 		// FAST PATH — to-one fetch only (deterministic, no duplication)
 		// ------------------------------------------------------------
 		if (!requiresIdFirst) {

 			JPQLQuery<ENTITY> query =
 					createQuery(filter, hints).select(path);

 			applySortOrDefaultById(query, criteria);

 			return query.fetch();
 		}

 		// ------------------------------------------------------------
 		// SAFE PATH — collection fetch allowed, ID-first + root dedup
 		// ------------------------------------------------------------

 		// Phase 1 — deterministic ID selection
 		JPQLQuery<ID> idQuery =
 				createQuery(filter).select(idExpr);

 		applySortOrDefaultById(idQuery, criteria);
+		assertNoAdditionalJoins((AbstractJPAQuery<?, ?>) idQuery, "findAll.idQuery");

 		List<ID> ids = idQuery.fetch();
 		if (ids.isEmpty()) {
 			return List.of();
 		}

 		// Phase 2 — entity fetch with fetch graph
 		JPQLQuery<ENTITY> entityQuery =
 				createQuery(idExpr.in(ids), hints).select(path);

 		applyStableOrderAfterIdPaging(entityQuery, criteria, ids);

 		List<ENTITY> rows = entityQuery.fetch();

 		// ------------------------------------------------------------
 		// STRICT ROOT DEDUPLICATION (safe because NO pagination)
 		// ------------------------------------------------------------
 		// JPA may return duplicate roots when fetching collections.
 		// Dedup is REQUIRED here to preserve set semantics.
 		// This does NOT hide paging bugs because paging is forbidden.
-		Map<Long, ENTITY> unique = new LinkedHashMap<>(rows.size());
-
-		for (ENTITY e : rows) {
-			unique.putIfAbsent(e.getId(), e);
-		}
+		Map<ID, ENTITY> unique = deduplicateById(rows);

 		return new ArrayList<>(unique.values());
 	}

 	/**
 	 * Safe pagination method.
 	 *
 	 * <p>
 	 * Guarantees:
 	 * <ul>
 	 *   <li>Correct offset + limit behavior</li>
 	 *   <li>No in-memory pagination</li>
 	 *   <li>No duplicate rows</li>
 	 *   <li>Stable ordering</li>
 	 * </ul>
 	 * </p>
 	 */
 	@Override
 	public Page<ENTITY> findByPaging(CRITERIA criteria, String... hints) {

 		Assert.notNull(criteria, "Criteria must not be null");

 		Pageable pageable = criteria.toPageable();
 		Assert.notNull(pageable, "Pageable must not be null");

@@ -397,131 +563,149 @@ public abstract class AbstractRepositoryImpl<
 					createQuery(filter, hints).select(path);

 			applySortOrDefaultById(query, criteria);

 			query = query.offset(pageable.getOffset())
 					.limit(pageable.getPageSize());

 			List<ENTITY> content = query.fetch();
 			long total = count(criteria);

 			return new PageImpl<>(content, pageable, total);
 		}

 		// ------------------------------------------------------------
 		// PHASE 1 — ID PAGE (GLOBAL ORDER + OFFSET/LIMIT)
 		// ------------------------------------------------------------
 		JPQLQuery<ID> idQuery =
 				createQuery(filter).select(idExpr);

 		applySortOrDefaultById(idQuery, criteria);

 		idQuery = idQuery
 				.offset(pageable.getOffset())
 				.limit(pageable.getPageSize());

+		assertNoAdditionalJoins((AbstractJPAQuery<?, ?>) idQuery, "findByPaging.idQuery");
 		List<ID> ids = idQuery.fetch();

 		if (ids.isEmpty()) {
 			return Page.empty(pageable);
 		}

 		// ------------------------------------------------------------
 		// PHASE 2 — ENTITY FETCH
 		// ------------------------------------------------------------
 		JPQLQuery<ENTITY> entityQuery =
 				createQuery(idExpr.in(ids), hints).select(path);

 		applyStableOrderAfterIdPaging(entityQuery, criteria, ids);

-		List<ENTITY> content = entityQuery.fetch();
+		List<ENTITY> rows = entityQuery.fetch();
+		Map<ID, ENTITY> unique = deduplicateById(rows);
+		List<ENTITY> content = new ArrayList<>(unique.values());
+
+		if (content.size() != ids.size()) {
+			throw new IllegalStateException(
+					"Phase-2 fetch returned " + content.size() +
+							" unique roots for " + ids.size() + " ids. " +
+							"FetchGraph likely produced join-multiplication or filtered rows."
+			);
+		}
+
 		long total = count(criteria);

 		return new PageImpl<>(content, pageable, total);
 	}

 	/**
 	 * Returns matching entity IDs.
 	 *
 	 * <p>
 	 * Used internally for bulk operations.
 	 * Ordering does NOT affect correctness here.
 	 * </p>
 	 */
 	@Override
 	public List<ID> findIds(CRITERIA criteria) {

 		Assert.notNull(criteria, "Criteria must not be null");

 		Predicate filter = criteria.getFilter(path);

 		JPQLQuery<ID> query =
 				createQuery(filter).select(idExpr);

 		applySortOrDefaultById(query, criteria);
+		assertNoAdditionalJoins((AbstractJPAQuery<?, ?>) query, "findIds");

 		return query.fetch();
 	}

 	// ----------------------------------------------------------------------
 	// WRITE OPERATIONS
 	// ----------------------------------------------------------------------

 	/**
 	 * Count query with identical filter but no joins or pagination.
 	 *
 	 * <p>
 	 * STRICT: COUNT must match the same filter used for paging decisions.
 	 * No COUNT DISTINCT. No recovery.
 	 * </p>
 	 */
 	@Override
 	public long count(CRITERIA criteria) {

 		Assert.notNull(criteria, "Criteria must not be null");

 		Predicate filter = criteria.getFilter(path);

+		AbstractJPAQuery<?, ?> query = createQuery(filter);
+		assertNoAdditionalJoins(query, "count");
+
 		Long count =
-				createQuery(filter)
-						.select(idExpr.count())
+				query.select(idExpr.count())
 						.fetchOne();

 		return count == null ? 0L : count;
 	}

 	/**
 	 * Existence check.
 	 */
 	@Override
 	public boolean exists(CRITERIA criteria) {

 		Assert.notNull(criteria, "Criteria must not be null");

 		Predicate filter = criteria.getFilter(path);

-		return createQuery(filter)
+		AbstractJPAQuery<?, ?> query = createQuery(filter);
+		assertNoAdditionalJoins(query, "exists");
+
+		return query
 				.select(idExpr)
 				.fetchFirst() != null;
 	}

 	// ----------------------------------------------------------------------
 	// BULK OPERATIONS (ID-FIRST, SAFE)
 	// ----------------------------------------------------------------------

 	@Override
 	public ENTITY saveRecord(ENTITY entity) {
 		return super.saveAndFlush(entity);
 	}

 	@Override
 	public List<ENTITY> saveAllRecords(Iterable<ENTITY> entities) {
 		return super.saveAllAndFlush(entities);
 	}

 	@Override
 	public long updateById(
 			UpdateSpec<ENTITY> spec,
 			ID id,
 			long updatedBy) {

 		Assert.notNull(spec, "UpdateSpec must not be null");
@@ -623,50 +807,73 @@ public abstract class AbstractRepositoryImpl<
 	}

 	// ----------------------------------------------------------------------
 	// QUERY CONSTRUCTION
 	// ----------------------------------------------------------------------

 	protected AbstractJPAQuery<?, ?> createQuery(
 			Predicate predicate,
 			String... hints) {

 		AbstractJPAQuery<?, ?> query =
 				querydsl.createQuery(path);

 		if (predicate != null) {
 			query.where(predicate);
 		}

 		QueryHints qh = getRelatedDataHints(hints);
 		if (qh != null) {
 			qh.forEach(query::setHint);
 		}

 		return query;
 	}

+	protected void assertNoAdditionalJoins(AbstractJPAQuery<?, ?> query, String context) {
+
+		List<JoinExpression> joins = query.getMetadata().getJoins();
+		if (joins == null || joins.isEmpty()) {
+			return;
+		}
+
+		// The first join is the root entity (FROM). Any additional join is unsafe here.
+		if (joins.size() > 1) {
+			throw new IllegalStateException(
+					"Unsafe join detected in " + context + ". " +
+							"ID/count queries must not introduce additional joins. joins=" + joins
+			);
+		}
+
+		JoinExpression root = joins.getFirst();
+		if (!Objects.equals(root.getTarget(), path)) {
+			throw new IllegalStateException(
+					"Unexpected join root in " + context + ". Expected " + path + " but found " + root.getTarget()
+			);
+		}
+	}
+
 	protected final void afterBulkDml() {
 		entityManager.flush();
 		entityManager.clear();
 	}

 	protected void applyAudit(
 			JPAUpdateClause update,
 			Long updatedBy) {

 		update.set(audit.updatedDate, LocalDateTime.now());
 		update.set(audit.updatedBy, updatedBy);
 	}

 	// ----------------------------------------------------------------------
 	// SORT SAFETY ENFORCEMENT (STRICT – FAIL FAST)
 	// ----------------------------------------------------------------------

 	/**
 	 * Validates that ORDER BY clauses do NOT traverse collection-valued paths.
 	 *
 	 * <p>
 	 * Sorting on to-many associations is mathematically incompatible with
 	 * OFFSET/LIMIT pagination and is therefore forbidden at framework level.
 	 * </p>
 	 *
diff --git a/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/service/base/BaseService.java b/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/service/base/BaseService.java
index b166adfcbb33e5ce4d7f81a1db8931b67f40ec8d..83f4603b6b90e0ea0cdccdd1c71ec5b49858a25d 100644
--- a/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/service/base/BaseService.java
+++ b/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/service/base/BaseService.java
@@ -12,51 +12,51 @@ import com.tamantaw.projectx.persistence.exception.PersistenceException;
 import com.tamantaw.projectx.persistence.mapper.base.AbstractMapper;
 import com.tamantaw.projectx.persistence.mapper.base.MappingContext;
 import com.tamantaw.projectx.persistence.repository.base.AbstractRepository;
 import com.tamantaw.projectx.persistence.repository.base.UpdateSpec;
 import jakarta.persistence.EntityNotFoundException;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.dao.DataIntegrityViolationException;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.Pageable;
 import org.springframework.transaction.annotation.Transactional;
 import org.springframework.util.Assert;

 import java.io.Serializable;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;

 import static com.tamantaw.projectx.persistence.utils.LoggerConstants.DATA_INTEGRITY_VIOLATION_MSG;

 @Transactional(transactionManager = PrimaryPersistenceContext.TX_MANAGER, rollbackFor = Exception.class)
 public abstract class BaseService<
-		ID extends Serializable,
+		ID extends Serializable & Comparable<ID>,
 		ENTITY extends AbstractEntity,
 		QCLAZZ extends EntityPathBase<ENTITY>,
 		CRITERIA extends AbstractCriteria<QCLAZZ>,
 		DTO extends AbstractDTO,
 		MAPPER extends AbstractMapper<DTO, ENTITY>
 		> {

 	private static final Logger log =
 			LogManager.getLogger("serviceLogs." + BaseService.class.getSimpleName());

 	protected final MAPPER mapper;
 	protected final AbstractRepository<ID, ENTITY, QCLAZZ, CRITERIA> repository;

 	@Autowired
 	protected MappingContext mappingContext;

 	protected BaseService(
 			AbstractRepository<ID, ENTITY, QCLAZZ, CRITERIA> repository,
 			MAPPER mapper
 	) {
 		this.repository = repository;
 		this.mapper = mapper;
 	}

 // ----------------------------------------------------------------------
