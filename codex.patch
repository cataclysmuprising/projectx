diff --git a/README.md b/README.md
index cabff267f5629be1eee0db75613d3ccdca9d7369..6878caefb1b60c4ea518ad047d19afbac0492ee0 100644
--- a/README.md
+++ b/README.md
@@ -143,52 +143,52 @@ findAll(criteria with paging);  // ‚ùå throws exception
 ### `findByPaging()`
 - ‚úÖ The **only** paging entry point
 - Supports:
   - Offset + limit
   - Page number
   - Multi-column sorting
   - Nested criteria
   - Fetch graphs

 ```java
 findByPaging(criteria, "Role(roleActions(action))");
 ```

 ---

 ## üîÄ Sorting Rules

 - Supports **multi-column sorting**
 - Sorting is always applied:
   - Before paging (defines page membership)
   - After entity fetch (when required)
 - Invalid sort properties fail fast with clear errors

 Example:
 ```java
-criteria.addSort("roleType", Sort.Direction.ASC);
-criteria.addSort("id", Sort.Direction.DESC);
+criteria.addSort(QRole.role.roleType, Sort.Direction.ASC);
+criteria.addSort(QRole.role.id, Sort.Direction.DESC);
 ```

 ---

 ## üìä Counting Strategy

 - `count()` queries:
   - Never use JOINs
   - Use the same filter logic
   - Always reflect true dataset size

 Guarantees:
 - `recordsTotal` is correct
 - No mismatch between content and total

 ---

 ## üß™ Test Coverage

 The architecture is validated with integration tests covering:

 - Nested criteria with EXISTS
 - Multi-column sorting
 - Offset + limit paging
 - Fetch graphs with collections
@@ -215,26 +215,25 @@ findByPaging_withNestedCriteria_multiSort_andOffsetLimit()
 ## üìê Design Philosophy

 This persistence layer favors:

 - **Correctness over convenience**
 - **Explicit behavior over magic**
 - **Predictable SQL over ORM guesswork**
 - **Long-term stability over short-term shortcuts**

 It is suitable for:
 - Large datasets
 - Financial systems
 - Admin panels
 - Audited / regulated environments

 ---

 ## üèÅ Final Notes

 This is not boilerplate CRUD.

 This is a **carefully designed persistence foundation** intended to scale safely as:
 - New entities are added
 - New nested criteria are introduced
 - Dataset size grows
-
diff --git a/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/criteria/base/AbstractCriteria.java b/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/criteria/base/AbstractCriteria.java
index 25e9b07031c44db76244833b26425233b964380f..77cd96e879e3ff63255813739246263b9f016080 100644
--- a/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/criteria/base/AbstractCriteria.java
+++ b/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/criteria/base/AbstractCriteria.java
@@ -1,83 +1,87 @@
 package com.tamantaw.projectx.persistence.criteria.base;

 import com.querydsl.core.BooleanBuilder;
+import com.querydsl.core.types.Order;
+import com.querydsl.core.types.OrderSpecifier;
 import com.querydsl.core.types.Predicate;
+import com.querydsl.core.types.Path;
 import com.querydsl.core.types.dsl.EntityPathBase;
+import com.querydsl.core.types.dsl.ComparableExpressionBase;
+import com.querydsl.core.types.dsl.PathBuilder;
 import com.tamantaw.projectx.persistence.entity.base.QAbstractEntity;
 import lombok.Data;
-import org.apache.commons.lang3.StringUtils;
 import org.springframework.data.domain.PageRequest;
 import org.springframework.data.domain.Pageable;
 import org.springframework.data.domain.Sort;
 import org.springframework.util.CollectionUtils;

 import java.time.LocalDateTime;
 import java.util.*;

 @Data
 public abstract class AbstractCriteria<A extends EntityPathBase<?>> {

 	// ----------------------------------------------------------------------
 	// DEFAULTS
 	// ----------------------------------------------------------------------

 	protected static final int DEFAULT_PAGE_SIZE = 20;
 	protected static final int DEFAULT_MAX_ROWS = 100;

 	// ----------------------------------------------------------------------
 	// COMMON FILTER FIELDS
 	// ----------------------------------------------------------------------

 	protected Long id;
 	protected Long fromId;

 	protected Set<Long> includeIds;
 	protected Set<Long> excludeIds;

 	protected Long createdBy;
 	protected Long updatedBy;

 	protected LocalDateTime createdDateFrom;
 	protected LocalDateTime createdDateTo;
 	protected LocalDateTime updatedDateFrom;
 	protected LocalDateTime updatedDateTo;

 	// COMMON KEYWORD
 	protected String keyword;

 	// ----------------------------------------------------------------------
 	// SORTING (MULTI-COLUMN)
 	// ----------------------------------------------------------------------

 	/**
 	 * Ordered sort fields.
 	 * Example:
 	 * id -> DESC
 	 * name -> ASC
 	 */
-	protected final LinkedHashMap<String, Sort.Direction> sortOrders = new LinkedHashMap<>();
+	protected final List<OrderSpecifier<?>> orderSpecifiers = new ArrayList<>();

 	// ----------------------------------------------------------------------
 	// PAGING INPUTS
 	// ----------------------------------------------------------------------

 	/**
 	 * Page number (1-based, controller-friendly).
 	 * If provided, offset is calculated automatically.
 	 */
 	protected Integer pageNumber;

 	/**
 	 * Zero-based offset (advanced usage).
 	 */
 	protected Integer offset;

 	/**
 	 * Page size / limit.
 	 */
 	protected Integer limit;

 	// ----------------------------------------------------------------------
 	// COMMON FILTER LOGIC
 	// ----------------------------------------------------------------------

@@ -101,67 +105,112 @@ public abstract class AbstractCriteria<A extends EntityPathBase<?>> {
 			predicate.and(audit.createdDate.goe(createdDateFrom));
 		}
 		if (createdDateTo != null) {
 			predicate.and(audit.createdDate.loe(createdDateTo));
 		}
 		if (updatedDateFrom != null) {
 			predicate.and(audit.updatedDate.goe(updatedDateFrom));
 		}
 		if (updatedDateTo != null) {
 			predicate.and(audit.updatedDate.loe(updatedDateTo));
 		}
 		if (!CollectionUtils.isEmpty(includeIds)) {
 			predicate.and(audit.id.in(includeIds));
 		}
 		if (!CollectionUtils.isEmpty(excludeIds)) {
 			predicate.and(audit.id.notIn(excludeIds));
 		}

 		return predicate;
 	}

 	// ----------------------------------------------------------------------
 	// SORTING
 	// ----------------------------------------------------------------------

-	public void addSort(String property, Sort.Direction direction) {
-		if (StringUtils.isNotBlank(property) && direction != null) {
-			sortOrders.put(property, direction);
+	public void addSort(
+			ComparableExpressionBase<? extends Comparable<?>> property,
+			Sort.Direction direction) {
+
+		if (property == null || direction == null) {
+			return;
+		}
+
+		Order order = direction.isAscending() ? Order.ASC : Order.DESC;
+		orderSpecifiers.add(new OrderSpecifier<>(order, property));
+	}
+
+	public List<OrderSpecifier<?>> resolveOrderSpecifiers(EntityPathBase<?> root) {
+
+		if (!CollectionUtils.isEmpty(orderSpecifiers)) {
+			return List.copyOf(orderSpecifiers);
+		}
+
+		if (root == null) {
+			return Collections.emptyList();
 		}
+
+		PathBuilder<?> pb =
+				new PathBuilder<>(root.getType(), root.getMetadata());
+
+		return List.of(new OrderSpecifier<>(Order.DESC, pb.getComparable("id", Comparable.class)));
 	}

 	public Sort resolveSort() {

-		if (sortOrders.isEmpty()) {
+		List<OrderSpecifier<?>> orders = resolveOrderSpecifiers(null);
+		if (CollectionUtils.isEmpty(orders)) {
 			return Sort.by(Sort.Direction.DESC, "id");
 		}

-		List<Sort.Order> orders = new ArrayList<>();
-		for (Map.Entry<String, Sort.Direction> e : sortOrders.entrySet()) {
-			orders.add(new Sort.Order(e.getValue(), e.getKey()));
+		List<Sort.Order> sortOrders = new ArrayList<>();
+		for (OrderSpecifier<?> o : orders) {
+			Sort.Direction direction =
+					o.getOrder() == Order.ASC ? Sort.Direction.ASC : Sort.Direction.DESC;
+
+			String propertyName = resolvePropertyName(o);
+			if (propertyName == null) {
+				throw new IllegalArgumentException(
+						"Unable to resolve property name from order specifier: " + o
+				);
+			}
+
+			sortOrders.add(new Sort.Order(direction, propertyName));
+		}
+		return Sort.by(sortOrders);
+	}
+
+	private String resolvePropertyName(OrderSpecifier<?> orderSpecifier) {
+		if (orderSpecifier == null || orderSpecifier.getTarget() == null) {
+			return null;
+		}
+
+		if (orderSpecifier.getTarget() instanceof Path<?> path) {
+			return path.getMetadata().getName();
 		}
-		return Sort.by(orders);
+
+		return null;
 	}

 	// ----------------------------------------------------------------------
 	// PAGING
 	// ----------------------------------------------------------------------

 	/**
 	 * Computes {@link Pageable} dynamically based on controller inputs.
 	 *
 	 * <p><b>Supported controller input combinations</b>:
 	 * <ul>
 	 *   <li><b>pageNumber only</b> ‚Üí offset is auto-calculated</li>
 	 *   <li><b>pageNumber + limit</b> ‚Üí offset is auto-calculated</li>
 	 *   <li><b>offset + limit</b> ‚Üí raw offset-based paging</li>
 	 *   <li><b>nothing provided</b> ‚Üí paging is NOT applied</li>
 	 * </ul>
 	 *
 	 * <p><b>Important contract rule</b>:
 	 * <ul>
 	 *   <li>Paging is <b>opt-in</b>.</li>
 	 *   <li>{@code limit} alone must NOT trigger paging.</li>
 	 *   <li>{@code findAll()} must never silently truncate results.</li>
 	 * </ul>
 	 */
 	public Pageable toPageable() {
diff --git a/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepositoryImpl.java b/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepositoryImpl.java
index 30e99925aed2d9c5a10238d67aa1b972cb29394b..91774ff9789618aae49a163662dd5bc9dc97dee6 100644
--- a/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepositoryImpl.java
+++ b/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepositoryImpl.java
@@ -1,45 +1,44 @@
 package com.tamantaw.projectx.persistence.repository.base;

 import com.querydsl.core.types.EntityPath;
 import com.querydsl.core.types.Predicate;
 import com.querydsl.core.types.dsl.*;
 import com.querydsl.jpa.JPQLQuery;
 import com.querydsl.jpa.impl.AbstractJPAQuery;
 import com.querydsl.jpa.impl.JPAQueryFactory;
 import com.querydsl.jpa.impl.JPAUpdateClause;
 import com.tamantaw.projectx.persistence.criteria.base.AbstractCriteria;
 import com.tamantaw.projectx.persistence.entity.base.AbstractEntity;
 import com.tamantaw.projectx.persistence.entity.base.QAbstractEntity;
 import jakarta.persistence.EntityManager;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.PageImpl;
 import org.springframework.data.domain.Pageable;
-import org.springframework.data.domain.Sort;
 import org.springframework.data.jpa.repository.support.*;
 import org.springframework.data.querydsl.EntityPathResolver;
 import org.springframework.data.querydsl.SimpleEntityPathResolver;
 import org.springframework.util.Assert;

 import javax.annotation.Nonnull;
 import java.io.Serializable;
 import java.lang.reflect.Field;
 import java.time.LocalDateTime;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;

 /**
  * Base JPA repository implementation with:
  * <p>
  * - QueryDSL-based dynamic criteria
  * - N+1-safe fetching
  * - Pagination-safe ordering
  * - Deterministic results across databases
  * - Explicit API contracts
  *
  * <p>
  * This class intentionally avoids ‚Äúmagic behavior‚Äù.
  * Every performance-critical decision is explicit and documented.
@@ -451,76 +450,58 @@ public abstract class AbstractRepositoryImpl<
 		if (predicate != null) {
 			query.where(predicate);
 		}

 		QueryHints qh = getRelatedDataHints(hints);
 		if (qh != null) {
 			qh.forEach(query::setHint);
 		}

 		return query;
 	}

 	protected void applyAudit(
 			JPAUpdateClause update,
 			Long updatedBy) {

 		update.set(audit.updatedDate, LocalDateTime.now());
 		update.set(audit.updatedBy, updatedBy);
 	}

 	/**
 	 * Applies dynamic ORDER BY based on criteria.
 	 */
 	protected void applySort(JPQLQuery<?> query, CRITERIA criteria) {

-		Sort sort = criteria.resolveSort();
-		if (sort == null || !sort.isSorted()) {
+		List<OrderSpecifier<?>> orderSpecifiers =
+				criteria.resolveOrderSpecifiers(path);
+
+		if (orderSpecifiers == null || orderSpecifiers.isEmpty()) {
 			return;
 		}

-		PathBuilder<?> pb =
-				new PathBuilder<>(path.getType(), path.getMetadata());
-
-		for (Sort.Order o : sort) {
-			try {
-				ComparableExpressionBase<?> exp =
-						pb.getComparable(o.getProperty(), Comparable.class);
-
-				query.orderBy(
-						o.isAscending() ? exp.asc() : exp.desc()
-				);
-			}
-			catch (IllegalArgumentException ex) {
-				throw new IllegalArgumentException(
-						"Invalid sort property '" + o.getProperty() + "' for entity "
-								+ path.getType().getSimpleName()
-								+ ". Ensure the field exists and is Comparable.",
-						ex
-				);
-			}
-		}
+		query.orderBy(orderSpecifiers.toArray(new OrderSpecifier<?>[0]));
 	}

 	protected int bulkInChunkSize() {
 		return 1000;
 	}

 	/**
 	 * Preserves ID order explicitly using CASE expressions.
 	 *
 	 * <p>
 	 * Used only for non-Postgres databases.
 	 * Page size bounds the SQL complexity.
 	 * </p>
 	 */
 	protected void applyIdOrder(
 			JPQLQuery<?> query,
 			List<Long> ids) {

 		if (ids == null || ids.isEmpty()) {
 			return;
 		}

 		CaseBuilder cb = new CaseBuilder();
 		CaseBuilder.Cases<Integer, NumberExpression<Integer>> cases = null;

@@ -576,26 +557,25 @@ public abstract class AbstractRepositoryImpl<
 		}

 		throw new IllegalStateException(
 				"QAbstractEntity audit path not resolvable"
 		);
 	}

 	private static <T> List<List<T>> chunk(
 			List<T> src,
 			int size) {

 		if (src == null || src.isEmpty()) {
 			return List.of();
 		}

 		List<List<T>> out =
 				new ArrayList<>((src.size() + size - 1) / size);

 		for (int i = 0; i < src.size(); i += size) {
 			out.add(src.subList(i, Math.min(src.size(), i + size)));
 		}

 		return out;
 	}
 }
-
diff --git a/projectx-persistence/src/test/java/com/tamantaw/projectx/integrationTests/RoleServiceIT.java b/projectx-persistence/src/test/java/com/tamantaw/projectx/integrationTests/RoleServiceIT.java
index 43a49f8893d18ef9172c8a9e9c8d81bff743c80d..6f750eda49dcba91480dd5761c3abca3ee745e6f 100644
--- a/projectx-persistence/src/test/java/com/tamantaw/projectx/integrationTests/RoleServiceIT.java
+++ b/projectx-persistence/src/test/java/com/tamantaw/projectx/integrationTests/RoleServiceIT.java
@@ -238,65 +238,65 @@ public class RoleServiceIT extends CommonTestBase {
 		assertNotNull(page);
 		assertTrue(page.getRecordsTotal() >= 2);
 		assertEquals(page.getNumber(), 0); // Spring Page is 0-based
 		assertTrue(page.getSize() > 0);    // should be DEFAULT_PAGE_SIZE (20) if you expose it
 	}

 	@Test
 	public void findByPaging_withPageNumberAndLimit() throws Exception {
 		RoleCriteria criteria = new RoleCriteria();
 		criteria.setAppName("projectx");
 		criteria.setPageNumber(1);
 		criteria.setLimit(1);

 		PaginatedResult<RoleDTO> page = roleService.findByPaging(criteria);

 		assertNotNull(page);
 		assertEquals(page.getNumber(), 0);
 		assertEquals(page.getSize(), 1);
 		assertEquals(page.getData().size(), 1);
 	}

 	@Test
 	public void findAll_sortedByIdDesc() throws Exception {
 		RoleCriteria criteria = new RoleCriteria();
 		criteria.setAppName("projectx");
-		criteria.addSort("id", Sort.Direction.DESC);
+		criteria.addSort(QRole.role.id, Sort.Direction.DESC);

 		List<RoleDTO> roles = roleService.findAll(criteria);

 		assertTrue(roles.size() >= 2);
 		assertTrue(roles.get(0).getId() > roles.get(1).getId());
 	}

 	@Test
 	public void findAll_multiSort_roleTypeAsc_nameAsc() throws Exception {
 		RoleCriteria criteria = new RoleCriteria();
 		criteria.setAppName("projectx");

-		criteria.addSort("roleType", Sort.Direction.ASC);
-		criteria.addSort("name", Sort.Direction.ASC);
+		criteria.addSort(QRole.role.roleType, Sort.Direction.ASC);
+		criteria.addSort(QRole.role.name, Sort.Direction.ASC);

 		List<RoleDTO> roles = roleService.findAll(criteria);

 		assertTrue(roles.size() >= 2);
 	}

 	@Test
 	public void findByPaging_withNestedActionCriteria() throws Exception {
 		ActionCriteria actionCriteria = new ActionCriteria();
 		actionCriteria.setPage("User");

 		RoleCriteria roleCriteria = new RoleCriteria();
 		roleCriteria.setAppName("projectx");
 		roleCriteria.setAction(actionCriteria);
 		roleCriteria.setLimit(10);
 		roleCriteria.setOffset(0);

 		PaginatedResult<RoleDTO> page =
 				roleService.findByPaging(roleCriteria, "Role(roleActions(action))");

 		assertFalse(page.getData().isEmpty());

 		assertTrue(
 				page.getData().stream()
 						.anyMatch(r -> "SUPER-USER".equals(r.getName()))
@@ -320,52 +320,52 @@ public class RoleServiceIT extends CommonTestBase {
 		assertFalse(roles.isEmpty());
 		assertTrue(
 				roles.stream().anyMatch(r -> "SUPER-USER".equals(r.getName()))
 		);
 	}

 	@Test
 	public void findByPaging_withNestedCriteria_multiSort_andOffsetLimit() throws Exception {

 		// ------------------------------------------------------------------
 		// GIVEN: nested Action criteria (forces EXISTS + ID-first paging)
 		// ------------------------------------------------------------------

 		ActionCriteria actionCriteria = new ActionCriteria();
 		actionCriteria.setPage("User");

 		RoleCriteria criteria = new RoleCriteria();
 		criteria.setAppName("projectx");
 		criteria.setAction(actionCriteria);

 		// ------------------------------------------------------------------
 		// GIVEN: multi-column global sorting
 		// ORDER BY roleType ASC, id DESC
 		// ------------------------------------------------------------------

-		criteria.addSort("roleType", Sort.Direction.ASC);
-		criteria.addSort("id", Sort.Direction.DESC);
+		criteria.addSort(QRole.role.roleType, Sort.Direction.ASC);
+		criteria.addSort(QRole.role.id, Sort.Direction.DESC);

 		// ------------------------------------------------------------------
 		// GIVEN: paging via offset + limit
 		// ------------------------------------------------------------------

 		criteria.setOffset(0);
 		criteria.setLimit(2);

 		// ------------------------------------------------------------------
 		// WHEN
 		// ------------------------------------------------------------------

 		PaginatedResult<RoleDTO> page =
 				roleService.findByPaging(criteria, "Role(roleActions(action))");

 		// ------------------------------------------------------------------
 		// THEN: paging metadata
 		// ------------------------------------------------------------------

 		assertNotNull(page);
 		assertTrue(page.getRecordsTotal() > 0);
 		assertEquals(page.getSize(), 2);
 		assertTrue(page.getNumberOfElements() <= 2);
 		assertFalse(page.getData().isEmpty());

@@ -376,26 +376,26 @@ public class RoleServiceIT extends CommonTestBase {
 		// ------------------------------------------------------------------

 		RoleDTO first = roles.getFirst();
 		assertNotNull(first.getActions());
 		assertFalse(first.getActions().isEmpty());

 		// ------------------------------------------------------------------
 		// THEN: ordering must respect DB semantics
 		// roleType ASC (DB value), id DESC (within same roleType)
 		// ------------------------------------------------------------------

 		for (int i = 1; i < roles.size(); i++) {

 			RoleDTO prev = roles.get(i - 1);
 			RoleDTO curr = roles.get(i);

 			// Only assert ID order when roleType is equal
 			if (prev.getRoleType().equals(curr.getRoleType())) {
 				assertTrue(
 						prev.getId() >= curr.getId(),
 						"Expected id DESC ordering within same roleType"
 				);
 			}
 		}
 	}
-}
\ No newline at end of file
+}
