diff --git a/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepositoryImpl.java b/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepositoryImpl.java
index 714c193bac0aabfa5d9a0bbd4a4e5e12f9963033..17445da7eb4e96aa539064c5df1add8be02cee4e 100644
--- a/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepositoryImpl.java
+++ b/projectx-persistence/src/main/java/com/tamantaw/projectx/persistence/repository/base/AbstractRepositoryImpl.java
@@ -92,100 +92,107 @@ public abstract class AbstractRepositoryImpl<
 	 * <ul>
 	 *   <li>We do NOT auto-detect the DB dialect.</li>
 	 *   <li>Auto-detection hides behavior and may change after upgrades.</li>
 	 *   <li>This flag makes pagination behavior explicit and reviewable.</li>
 	 * </ul>
 	 *
 	 * <p>
 	 * ‚ö†Ô∏è Changing this flag affects SQL generation and must be reviewed
 	 * together with DB choice and indexing strategy.
 	 * </p>
 	 */
 	public static final boolean IS_POSTGRES_DB = true;

 	private static final EntityPathResolver PATH_RESOLVER =
 			SimpleEntityPathResolver.INSTANCE;

 	private static final Logger logger =
 			LogManager.getLogger("repositoryLogs." + AbstractRepositoryImpl.class.getName());

 	// ----------------------------------------------------------------------
 	// CORE FIELDS
 	// ----------------------------------------------------------------------

 	protected final EntityManager entityManager;
 	protected final SimpleExpression<ID> idExpr;
+	protected final OrderSpecifier<?> idAscOrder;
 	protected final QCLAZZ path;
 	protected final QAbstractEntity audit;
 	protected final Querydsl querydsl;
 	protected final JPAQueryFactory queryFactory;

 	// ----------------------------------------------------------------------
 	// CONSTRUCTOR
 	// ----------------------------------------------------------------------

 	protected AbstractRepositoryImpl(
 			Class<ENTITY> domainClass,
 			Class<ID> idClass,
 			EntityManager entityManager) {

 		super(
 				new JpaMetamodelEntityInformation<>(
 						domainClass,
 						entityManager.getMetamodel(),
 						entityManager.getEntityManagerFactory().getPersistenceUnitUtil()
 				),
 				entityManager
 		);

 		this.entityManager = entityManager;

 		@SuppressWarnings("unchecked")
 		QCLAZZ resolved = (QCLAZZ) PATH_RESOLVER.createPath(domainClass);
 		path = resolved;

 		PathBuilder<ENTITY> builder =
 				new PathBuilder<>(path.getType(), path.getMetadata());

 		querydsl = new Querydsl(entityManager, builder);
 		queryFactory = new JPAQueryFactory(entityManager);

 		audit = resolveAuditPath(path);

 		IdentifiableType<ENTITY> identifiable =
 				(IdentifiableType<ENTITY>) entityManager
 						.getMetamodel()
 						.managedType(domainClass);

 		SingularAttribute<? super ENTITY, ID> idAttr =
 				identifiable.getId(idClass);

 		idExpr = Expressions.simplePath(
 				idClass,
 				path,
 				idAttr.getName()
 		);
+
+		@SuppressWarnings("unchecked")
+		Expression<? extends Comparable<?>> comparableIdExpr =
+				(Expression<? extends Comparable<?>>) idExpr;
+
+		idAscOrder = new OrderSpecifier<>(Order.ASC, comparableIdExpr);
 	}

 	// ----------------------------------------------------------------------
 	// READ OPERATIONS
 	// ----------------------------------------------------------------------

 	protected static QueryHints getRelatedDataHints(String... hints) {
 		if (ArrayUtils.isNotEmpty(hints)) {
 			MutableQueryHints qh = new MutableQueryHints();
 			qh.add("jakarta.persistence.fetchgraph", String.join(",", hints));
 			return qh;
 		}
 		return null;
 	}

 	private static <T> List<List<T>> chunk(List<T> src, int size) {

 		if (src == null || src.isEmpty()) {
 			return List.of();
 		}

 		List<List<T>> out =
 				new ArrayList<>((src.size() + size - 1) / size);

 		for (int i = 0; i < src.size(); i += size) {
@@ -752,66 +759,66 @@ public abstract class AbstractRepositoryImpl<

 	protected void applySort(JPQLQuery<?> query, CRITERIA criteria) {

 		List<OrderSpecifier<?>> orderSpecifiers =
 				criteria.resolveOrderSpecifiers(path);

 		if (orderSpecifiers == null || orderSpecifiers.isEmpty()) {
 			return;
 		}

 		// üîí STRICT FAIL FAST ‚Äî prevent pagination-unsafe sorting
 		validateSortSafety(orderSpecifiers);

 		query.orderBy(orderSpecifiers.toArray(new OrderSpecifier<?>[0]));
 	}

 	protected void applySortOrDefaultById(
 			JPQLQuery<?> query,
 			CRITERIA criteria) {

 		List<OrderSpecifier<?>> specs =
 				criteria.resolveOrderSpecifiers(path);

 		// No sort provided ‚Üí deterministic default
 		if (specs == null || specs.isEmpty()) {
-			query.orderBy(new OrderSpecifier<>(Order.ASC, idExpr));
+			query.orderBy(idAscOrder);
 			return;
 		}

 		// Fail fast on unsafe ORDER BY
 		validateSortSafety(specs);

 		// Always enforce TOTAL ordering
 		boolean hasIdOrder = specs.stream()
 				.anyMatch(o -> o.getTarget().equals(idExpr));

 		if (!hasIdOrder) {
 			List<OrderSpecifier<?>> withTieBreaker =
 					new ArrayList<>(specs.size() + 1);
 			withTieBreaker.addAll(specs);
-			withTieBreaker.add(new OrderSpecifier<>(Order.ASC, idExpr));
+			withTieBreaker.add(idAscOrder);

 			query.orderBy(withTieBreaker.toArray(new OrderSpecifier<?>[0]));
 		}
 		else {
 			query.orderBy(specs.toArray(new OrderSpecifier<?>[0]));
 		}
 	}

 	// ----------------------------------------------------------------------
 	// STABLE ORDERING AFTER ID PAGING
 	// ----------------------------------------------------------------------

 	/**
 	 * Applies stable ordering for the phase-2 entity fetch after an ID-page query.
 	 *
 	 * <p>
 	 * STRICT:
 	 * <ul>
 	 *   <li>If PostgreSQL: reapply original ORDER BY (same as phase 1).</li>
 	 *   <li>If non-Postgres: preserve phase-1 order with CASE ordering.</li>
 	 *   <li>No silent fallback. If CASE would exceed safe bounds, throw.</li>
 	 * </ul>
 	 * </p>
 	 */
 	protected void applyStableOrderAfterIdPaging(
