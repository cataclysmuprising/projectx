diff --git a/README.md b/README.md
index 0489ae71c05edb80c48f65ffbcdad0a9243564f7..82e66f7f2c97eecb4ed0d99a18ac24f38bc56d90 100644
--- a/README.md
+++ b/README.md
@@ -31,50 +31,51 @@ ProjectX is now a full-stack template that pairs a deterministic persistence lay
 - Built with **Maven**; backend packaged as a **WAR** for deployment to **Apache Tomcat 11** (also runnable via `spring-boot:run` in dev).
 - **Minification flow:** run the `projectx-compressor` module to install Node/npm, execute `esbuild`, and emit optimized assets consumed by the backend‚Äôs `_production` profile.
 - Tested on **Spring Boot 4 / Spring Framework 7** stack with Java 23.
 - **Windows packaging:** run `generate_war_os_window.bat` to build a Tomcat-ready WAR with the production asset pipeline.

 ---

 ## üóÉÔ∏è Database migrations

 - Default database name: **`projectx`**.
 - To run migration scripts manually, point your client to the `projectx` database and execute the SQL files in order from `projectx-persistence/src/main/resources/migration`. This keeps the schema aligned when applying changes outside automated pipelines.

 ---

 ## üóÑÔ∏è Persistence Layer Architecture (JPA + Hibernate + QueryDSL)

 This project implements a **deterministic, pagination-safe, and fetch-graph-safe persistence architecture** on top of **Spring Data JPA + Hibernate + QueryDSL**.

 It is designed to handle:

 - Complex nested filters
 - Multi-column sorting
 - Large datasets
 - Collection fetch graphs
 - Stable pagination without data corruption
+- ORDER BY safety guard that blocks collection-valued sorting and keeps pagination deterministic

 ---

 ### üìå Core Principles

 #### 1. Deterministic Pagination (No Data Corruption)

 Pagination **must always return the correct global ordering** for a given:

 ```
 WHERE + ORDER BY + OFFSET + LIMIT
 ```

 This repository **does not rely on JOIN-based pagination**, which is known to cause:

 - Duplicate rows
 - Missing records
 - Incorrect page boundaries
 - Hibernate in-memory paging warnings

 ---

 #### 2. EXISTS-Based Nested Filtering (No JOIN Filters)

 All nested criteria are implemented using **`EXISTS` subqueries**, never JOINs.
@@ -141,70 +142,57 @@ FROM table
 WHERE filter
 ORDER BY sort
 OFFSET / LIMIT
 ```

 Defines **exact page membership**.

 #### Phase 2 ‚Äî Entity Fetch

 ```
 SELECT entity
 FROM table
 LEFT JOIN collections
 WHERE id IN (:ids)
 ORDER BY <strategy>
 ```

 Ensures:

 - No Hibernate paging warnings
 - No incorrect result sets
 - No duplicated entities

 ---

-## üêò PostgreSQL Optimization
+## üêò DB-aware pagination ordering

-```java
-public static final boolean IS_POSTGRES_DB = true;
-```
-
-### Why this flag exists
-
-- PostgreSQL guarantees **deterministic ORDER BY behavior**
-- Allows safe reapplication of `ORDER BY` in Phase 2
-- Avoids SQL hacks like `CASE` or `array_position`
-
-### Behavior
-
-| Database   | Phase-2 Ordering                      |
-|------------|---------------------------------------|
-| PostgreSQL | Re-apply `ORDER BY`                   |
-| Other DBs  | Preserve ID order via CASE expression |
-
-> ‚ö†Ô∏è This flag is **explicit by design** ‚Äî no auto-detection magic.
+- No more `IS_POSTGRES_DB` flag to toggle by hand.
+- Phase 2 (entity fetch) now auto-selects the safe ordering strategy:
+  - PostgreSQL: re-apply the original `ORDER BY`.
+  - Other databases: preserve ID order explicitly via `CASE` over the page IDs.
+- Keeps pagination deterministic without hidden auto-detection while avoiding config switches.

 ---

 ## üö´ API Contract Rules

 ### `findAll()`

 - ‚ùå Paging NOT allowed
 - ‚úÖ Sorting allowed
 - Used only for full result sets

 ```java
 findAll(criteria);              // OK

 findAll(criteria with paging);  // ‚ùå throws exception
 ```

 ---

 ### `findByPaging()`

 - ‚úÖ The **only** paging entry point
 - Supports:
     - Offset + limit
     - Page number
