diff --git a/README.md b/README.md
index 6878caefb1b60c4ea518ad047d19afbac0492ee0..e97137b4e5c0a368388da5fbdb16bbe89aa73eef 100644
--- a/README.md
+++ b/README.md
@@ -1,57 +1,101 @@
-# Persistence Layer Architecture (JPA + Hibernate + QueryDSL)
+# ProjectX Template ‚Äì Spring Boot 4 + Spring 7 + Thymeleaf UI
+
+ProjectX is now a full-stack template that pairs a deterministic persistence layer with a production-ready web UI. It ships as a multi-module Maven build targeting **Java 23** and has been validated on **Apache Tomcat 11**.
+
+- **Frameworks:** Spring Framework 7, Spring Boot 4 (WAR packaging), Spring Security, Spring Web MVC, Spring WebFlux (client), Spring Data JPA, QueryDSL.
+- **Frontend:** Thymeleaf templates powered by **AdminLTE 3** components (https://adminlte.io/themes/v3/) and **jQuery** scripting.
+- **Database:** PostgreSQL-first design with QueryDSL, Hibernate, and MapStruct mappings.
+- **Build tools:** Maven + frontend-maven-plugin, esbuild-based minifier, Log4j2 logging.
+
+---
+
+## üß© Module layout
+
+- **`projectx-backend`** ‚Äì Web module with Thymeleaf views, AdminLTE 3 UI assets, Spring MVC controllers, and Spring Security configuration. Packages as a WAR for Tomcat 11, with dev and prod profiles.
+- **`projectx-persistence`** ‚Äì Deterministic JPA + Hibernate + QueryDSL persistence layer with pagination-safe query patterns, PostgreSQL tuning, and Redis L2 cache support.
+- **`projectx-compressor`** ‚Äì Asset optimizer that installs Node (via `frontend-maven-plugin`) and runs `esbuild` to minify JS/CSS before packaging the backend WAR.
+
+---
+
+## üé® UI layer highlights
+
+- **AdminLTE 3** styles, widgets, and layout building blocks available under `src/main/resources/static` and Thymeleaf `templates/`.
+- **Thymeleaf** templating for server-rendered pages, with Java 8 time utilities and Spring Security dialect for authorization-aware fragments.
+- **jQuery-first scripting** for client-side interactivity and lightweight behaviors.
+- **Profile-aware assets**: in production, static resources are generated by the compressor module and copied into the backend WAR; in development, raw assets are served directly.
+
+---
+
+## üöÄ Build & runtime
+
+- Built with **Maven**; backend packaged as a **WAR** for deployment to **Apache Tomcat 11** (also runnable via `spring-boot:run` in dev).
+- **Minification flow:** run the `projectx-compressor` module to install Node/npm, execute `esbuild`, and emit optimized assets consumed by the backend‚Äôs `_production` profile.
+- Tested on **Spring Boot 4 / Spring Framework 7** stack with Java 23.
+- **Windows packaging:** run `generate_war_os_window.bat` to build a Tomcat-ready WAR with the production asset pipeline.
+
+---
+
+## üóÉÔ∏è Database migrations
+
+- Default database name: **`projectx`**.
+- To run migration scripts manually, point your client to the `projectx` database and execute the SQL files in order from `projectx-persistence/src/main/resources/migration`. This keeps the schema aligned when applying changes outside automated pipelines.
+
+---
+
+## üóÑÔ∏è Persistence Layer Architecture (JPA + Hibernate + QueryDSL)

 This project implements a **deterministic, pagination-safe, and fetch-graph-safe persistence architecture** on top of **Spring Data JPA + Hibernate + QueryDSL**.

 It is designed to handle:

 - Complex nested filters
 - Multi-column sorting
 - Large datasets
 - Collection fetch graphs
 - Stable pagination without data corruption

 ---

-## üìå Core Principles
+### üìå Core Principles

-### 1. Deterministic Pagination (No Data Corruption)
+#### 1. Deterministic Pagination (No Data Corruption)
 Pagination **must always return the correct global ordering** for a given:

 ```
 WHERE + ORDER BY + OFFSET + LIMIT
 ```

 This repository **does not rely on JOIN-based pagination**, which is known to cause:
 - Duplicate rows
 - Missing records
 - Incorrect page boundaries
 - Hibernate in-memory paging warnings

 ---

-### 2. EXISTS-Based Nested Filtering (No JOIN Filters)
+#### 2. EXISTS-Based Nested Filtering (No JOIN Filters)
 All nested criteria are implemented using **`EXISTS` subqueries**, never JOINs.

 ‚úÖ Correct
 ```sql
 WHERE EXISTS (
   SELECT 1 FROM role_action ra
   JOIN action a ON a.id = ra.action_id
   WHERE ra.role_id = role.id
     AND a.page = 'User'
 )
 ```

 ‚ùå Forbidden
 ```sql
 LEFT JOIN role_action ra ...
 WHERE a.page = 'User'
 ```

 This guarantees:
 - Correct counts
 - Stable paging
 - No accidental row multiplication

 ---

