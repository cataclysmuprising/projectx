# ProjectX Template ‚Äì Spring Boot 4 + Spring 7 + Thymeleaf UI

ProjectX is now a full-stack template that pairs a deterministic persistence layer with a production-ready web UI. It ships as a multi-module Maven build targeting **Java 23** and has been validated on **Apache Tomcat 11**.

- **Frameworks:** Spring Framework 7, Spring Boot 4 (WAR packaging), Spring Security, Spring Web MVC, Spring WebFlux (client), Spring Data JPA, QueryDSL.
- **Frontend:** Thymeleaf templates powered by **AdminLTE 3** components (https://adminlte.io/themes/v3/) and **jQuery** scripting.
- **Database:** PostgreSQL-first design with QueryDSL, Hibernate, and MapStruct mappings.
- **Build tools:** Maven + frontend-maven-plugin, esbuild-based minifier, Log4j2 logging.

---

## üß© Module layout

- **`projectx-backend`** ‚Äì Web module with Thymeleaf views, AdminLTE 3 UI assets, Spring MVC controllers, and Spring Security configuration. Packages as a WAR for Tomcat 11, with dev and prod profiles.
- **`projectx-persistence`** ‚Äì Deterministic JPA + Hibernate + QueryDSL persistence layer with pagination-safe query patterns, PostgreSQL tuning, and Redis L2 cache support.
- **`projectx-compressor`** ‚Äì Asset optimizer that installs Node (via `frontend-maven-plugin`) and runs `esbuild` to minify JS/CSS before packaging the backend WAR.

---

## üé® UI layer highlights

- **AdminLTE 3** styles, widgets, and layout building blocks available under `src/main/resources/static` and Thymeleaf `templates/`.
- **Thymeleaf** templating for server-rendered pages, with Java 8 time utilities and Spring Security dialect for authorization-aware fragments.
- **jQuery-first scripting** for client-side interactivity and lightweight behaviors.
- **Profile-aware assets**: in production, static resources are generated by the compressor module and copied into the backend WAR; in development, raw assets are served directly.

---

## üöÄ Build & runtime

- Built with **Maven**; backend packaged as a **WAR** for deployment to **Apache Tomcat 11** (also runnable via `spring-boot:run` in dev).
- **Minification flow:** run the `projectx-compressor` module to install Node/npm, execute `esbuild`, and emit optimized assets consumed by the backend‚Äôs `_production` profile.
- Tested on **Spring Boot 4 / Spring Framework 7** stack with Java 23.
- **Windows packaging:** run `generate_war_os_window.bat` to build a Tomcat-ready WAR with the production asset pipeline.

---

## üóÉÔ∏è Database migrations

- Default database name: **`projectx`**.
- To run migration scripts manually, point your client to the `projectx` database and execute the SQL files in order from `projectx-persistence/src/main/resources/migration`. This keeps the schema aligned when applying changes outside automated pipelines.

---

## üóÑÔ∏è Persistence Layer Architecture (JPA + Hibernate + QueryDSL)

This project implements a **deterministic, pagination-safe, and fetch-graph-safe persistence architecture** on top of **Spring Data JPA + Hibernate + QueryDSL**.

It is designed to handle:

- Complex nested filters
- Multi-column sorting
- Large datasets
- Collection fetch graphs
- Stable pagination without data corruption
- ORDER BY safety guard that blocks collection-valued sorting and keeps pagination deterministic

---

### üìå Core Principles

#### 1. Deterministic Pagination (No Data Corruption)

Pagination **must always return the correct global ordering** for a given:

```
WHERE + ORDER BY + OFFSET + LIMIT
```

This repository **does not rely on JOIN-based pagination**, which is known to cause:

- Duplicate rows
- Missing records
- Incorrect page boundaries
- Hibernate in-memory paging warnings

---

#### 2. EXISTS-Based Nested Filtering (No JOIN Filters)

All nested criteria are implemented using **`EXISTS` subqueries**, never JOINs.

‚úÖ Correct

```sql
WHERE EXISTS (
  SELECT 1 FROM role_action ra
  JOIN action a ON a.id = ra.action_id
  WHERE ra.role_id = role.id
    AND a.page = 'Administrator'
)
```

‚ùå Forbidden

```sql
LEFT JOIN role_action ra ...
WHERE a.page = 'Administrator'
```

This guarantees:

- Correct counts
- Stable paging
- No accidental row multiplication

---

## üß† Query Execution Strategy

### Fast Path (No Collection Fetch)

Used when:

- No collection fetch graphs are requested
- Only `@ManyToOne` / `@OneToOne` relations are fetched

Flow:

```
SELECT entity
FROM table
WHERE filter
ORDER BY sort
OFFSET / LIMIT
```

---

### ID-First Paging Path (Collection Fetch Safe)

Used when:

- Collection fetch graphs are requested
- Paging + sorting is required

#### Phase 1 ‚Äî ID Selection

```
SELECT id
FROM table
WHERE filter
ORDER BY sort
OFFSET / LIMIT
```

Defines **exact page membership**.

#### Phase 2 ‚Äî Entity Fetch

```
SELECT entity
FROM table
LEFT JOIN collections
WHERE id IN (:ids)
ORDER BY <strategy>
```

Ensures:

- No Hibernate paging warnings
- No incorrect result sets
- No duplicated entities

---

## üêò PostgreSQL Optimization

```java
public static final boolean IS_POSTGRES_DB = true;
```

### Why this flag exists

- PostgreSQL guarantees **deterministic ORDER BY behavior**
- Allows safe reapplication of `ORDER BY` in Phase 2
- Avoids SQL hacks like `CASE` or `array_position`

### Behavior

| Database   | Phase-2 Ordering                      |
|------------|---------------------------------------|
| PostgreSQL | Re-apply `ORDER BY`                   |
| Other DBs  | Preserve ID order via CASE expression |

> ‚ö†Ô∏è This flag is **explicit by design** ‚Äî no auto-detection magic.

---

## üö´ API Contract Rules

### `findAll()`

- ‚ùå Paging NOT allowed
- ‚úÖ Sorting allowed
- Used only for full result sets

```java
findAll(criteria);              // OK

findAll(criteria with paging);  // ‚ùå throws exception
```

---

### `findByPaging()`

- ‚úÖ The **only** paging entry point
- Supports:
    - Offset + limit
    - Page number
    - Multi-column sorting
    - Nested criteria
    - Fetch graphs

```java
findByPaging(criteria, "Role(roleActions(action))");
```

---

## üîÄ Sorting Rules

- Supports **multi-column sorting**
- Sorting is always applied:
    - Before paging (defines page membership)
    - After entity fetch (when required)
- Invalid sort properties fail fast with clear errors

Example:

```java
criteria.addSort(QRole.role.roleType, Sort.Direction.ASC);
criteria.

addSort(QRole.role.id, Sort.Direction.DESC);
```

---

## üìä Counting Strategy

- `count()` queries:
    - Never use JOINs
    - Use the same filter logic
    - Always reflect true dataset size

Guarantees:

- `recordsTotal` is correct
- No mismatch between content and total

---

## üß™ Test Coverage

The architecture is validated with integration tests covering:

- Nested criteria with EXISTS
- Multi-column sorting
- Offset + limit paging
- Fetch graphs with collections
- Deterministic ordering across pages

Example test:

```java
findByPaging_withNestedCriteria_multiSort_andOffsetLimit()
```

---

## üõ°Ô∏è What This Design Prevents

- ‚ùå Hibernate in-memory paging
- ‚ùå Duplicate entities
- ‚ùå Missing records
- ‚ùå Broken pagination with joins
- ‚ùå Incorrect total counts
- ‚ùå Non-deterministic ordering

---

## üìê Design Philosophy

This persistence layer favors:

- **Correctness over convenience**
- **Explicit behavior over magic**
- **Predictable SQL over ORM guesswork**
- **Long-term stability over short-term shortcuts**

It is suitable for:

- Large datasets
- Financial systems
- Admin panels
- Audited / regulated environments

---

## üèÅ Final Notes

This is not boilerplate CRUD.

This is a **carefully designed persistence foundation** intended to scale safely as:

- New entities are added
- New nested criteria are introduced
- Dataset size grows
